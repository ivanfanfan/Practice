The quicksort algorithm has a worst-case running time of ‚.n 2 / on an input array
of n numbers. Despite this slow worst-case running time, quicksort is often the
best practical choice for sorting because it is remarkably efûcient on average: its
expected running time is ‚.n lg n/ when all numbers are distinct, and the constant
factors hidden in the ‚.n lg n/ notation are small. Unlike merge sort, it also has
the advantage of sorting in place (see page 158), and it works well even in virtual-
memory environments.
Our study of quicksort is broken into four sections. Section 7.1 describes the
algorithm and an important subroutine used by quicksort for partitioning. Because
the behavior of quicksort is complex, we’ll start with an intuitive discussion of
its performance in Section 7.2 and analyze it precisely at the end of the chapter.
Section 7.3 presents a randomized version of quicksort. When all elements are
distinct, 1 this randomized algorithm has a good expected running time and no par-
ticular input elicits its worst-case behavior. (See Problem 7-2 for the case in which
elements may be equal.) Section 7.4 analyzes the randomized algorithm, showing
that it runs in ‚.n 2 / time in the worst case and, assuming distinct elements, in
expected O.n lg n/ time.
Figure 2.4 The operation of merge sort on the array A with length 8 that initially contains the
sequence h12; 3; 7; 9; 14; 6; 11; 2i. The indices p, q, and r into each subarray appear above their
values. Numbers in italics indicate the order in which the M ERGE-SORT and MERGE procedures are
called following the initial call of MERGE-SORT.A; 1; 8/.
D.n/ C aT .n=b/ C C.n/ otherwise :
Chapter 4 shows how to solve common recurrences of this form.
Sometimes, the n=b size of the divide step isn’t an integer. For example, the
MERGE-SORT procedure divides a problem of size n into subproblems of sizes
dn=2e and bn=2c. Since the difference between dn=2e and bn=2c is at most 1,
2.3 Designing algorithms
41
which for large n is much smaller than the effect of dividing n by 2, we’ll squint a
little and just call them both size n=2. As Chapter 4 will discuss, this simpliûcation
of ignoring üoors and ceilings does not generally affect the order of growth of a
solution to a divide-and-conquer recurrence.
Another convention we’ll adopt is to omit a statement of the base cases of the
recurrence, which we’ll also discuss in more detail in Chapter 4. The reason is
that the base cases are pretty much always T .n/ D ‚.1/ if n < n 0 for some
constant n 0 > 0. That’s because the running time of an algorithm on an input of
constant size is constant. We save ourselves a lot of extra writing by adopting this
convention.
Divide-and-Conquer
The divide-and-conquer method is a powerful strategy for designing asymptotically
efûcient algorithms. We saw an example of divide-and-conquer in Section 2.3.1
when learning about merge sort. In this chapter, we’ll explore applications of the
divide-and-conquer method and acquire valuable mathematical tools that you can
use to solve the recurrences that arise when analyzing divide-and-conquer algorithms.
Recall that for divide-and-conquer, you solve a given problem (instance) recursively.
If the problem is small enough4the base case4you just solve it directly
without recursing. Otherwise4the recursive case4you perform three characteristic steps:
Divide the problem into one or more subproblems that are smaller instances of the
same problem.
Conquer the subproblems by solving them recursively.
Combine the subproblem solutions to form a solution to the original problem.
A divide-and-conquer algorithm breaks down a large problem into smaller subproblems,
which themselves may be broken down into even smaller subproblems,
and so forth. The recursion bottoms out when it reaches a base case and the sub-
problem is small enough to solve directly without further recursing.
Recurrences
To analyze recursive divide-and-conquer algorithms, we’ll need some mathematical tools. A recurrence is an equation that describes a function in terms of its
value on other, typically smaller, arguments. Recurrences go hand in hand with
the divide-and-conquer method because they give us a natural way to characterize
the running times of recursive algorithms mathematically. You saw an example
of a recurrence in Section 2.3.2 when we analyzed the worst-case running time of
merge sort
